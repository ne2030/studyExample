// fp 방식의 로직 전개

// 아직 확실하게 아는 건 아니지만, 아래의 설명에 따르면 state 전체를 넘기면서 연결해주는 방식으로 전개를 해나간다.

/*
실용적인 관점에서 모나드의 가장 중요한 용도는 Side-Effect가 있는 Impure Function을 Pure Function인 것처럼 다루는 것이다.
대략적으로 설명하자면, Side-Effect는 보통 외부 상태(이하 State)가 있고 이것에 접근하여 생긴다. 반대로 Side-Effect가 없는 Pure Function은
모든 정보가 인수로 전달되어 외부 상태에 접근하지 않는다. 그렇다면 어떤 함수에 인수로 State를 전달하고 그에 대한 결과로 State를 리턴한다면
 외부 상태에 접근을 하지 않아도 되며 pure function이 된다. 이 때 State 외에도 결과값 a도 있을 것이다. 즉, 입력이 State면 출력이 (a, State)가 되는 것이다.
 (이것을 State->(a, State)라고 나타낸다.) 이러한 함수는 다양하게 있을 수 있으며 그 결과값도 a 뿐만 아니라 여러가지가 있을 것이다.
 그런데 하스켈은 순수 함수형 언어이기 때문에 함수를 합성하는 방식(f 와 g를 합성하면 g(f(x))가 되는 것처럼)으로 작성을 해야한다.
 그런데 만약 f가 State->(a, State), g가 State->(b, State)라면 f의 출력과 g의 입력 타입이 맞지 않게 된다.
 이 때 f의 결과값인 (a, State)를 a와 State로 분리해서 a는 g와 결합하여 새로운 함수 g'를 만들고 State를 이 새로운 함수 g'에 전달하는 방식을 사용하게 된다.
 이렇게 결합을 해주는 것이 bind(Haskell에서 >>=연산자)라고 하고 결합되는 것을 monad라고 한다. 여기서 끝이 아니라 필요하다면 함수를 더 잇는 것도 가능하며,
 이렇게 여러 개를 이으면 거대한 하나의 Pure Function이 된다. (예를 들어서 위의 경우 f와 g를 결합하면 입력이 State, 출력이 (b, State)인 함수가 된다.)
 */

// 그럼 여기서 의문, 모나드 처럼 짜야 하는가? 모든 함수를 ? state 전체라고 이해를 하고 있는데, 그게 아니라 그냥 해당 함수에 필요한 자료만 해당하는 것인지?
