<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

<div id="test">
    test box
</div>

<script>
    console.log('기본 프로퍼티 assign');
    var a = { type: 'original' };
    var b = { value: 10 };
    var c = Object.assign({}, a, b);
    c.type = 'transform';
    console.log('c.type = transform');
    console.log(`compare // c.type: '${c.type}' vs a.type: '${a.type}'`);

    console.log('deep 프로퍼티 assign ----');
    var d = { e: { f: 10 }};
    var g = Object.assign({}, d);
    console.log(`변경 전 d.e: ${JSON.stringify(d.e)} vs g.e: ${JSON.stringify(g.e)}`);
    g.e.f = 20;
    console.log('-- 1 --');
    console.log(`딥 프로퍼티 변경 g.e.f = 20 / d.e.f: ${d.e.f}`);
    console.log(' -- 2 --');
    console.log('g.e.i 로 새로운 값 할당 => g.e 자체는 안변하고 그냥 프로퍼티 추가');
    g.e.i = 100;
    console.log(`g.e: ${JSON.stringify(g.e)}   vs   d.e: ${JSON.stringify(d.e)}`)
    console.log('g.e 에 새로운 값 할당')
    g.e = { s: 70 };
    console.log(`기본 프로퍼티 변경 g.e = { s: 70 } // g.e: ${JSON.stringify(g.e)} vs d.e : ${JSON.stringify(d.e)}`);

// 결론: 오브젝트에서 기본 프로퍼티에 오브젝트를 다시 할당할 경우, 
// 기본 프로퍼티가 그 밸류값인 오브젝트를 참조하게 된다.
// 이는 다시말해 Cloning 을 하기 위해 Object.assign 을 하는 경우,
// 기본 프로퍼티만 복사를 하게 되고, 그 프로퍼티가 참조하는 배열 혹은 객체는 바뀌지 않는다.
// 따라서 기본 프로퍼티의 값 자체를 재할당 하는 경우는 기존 객체와 별개로 진행되지만,
// 그 기본 프로퍼티가 참조하고 있는 객체에 새로운 프로퍼티를 추가하거나 기존 프로퍼티를 변경하는
// 일은 원래의 오브젝트에 영향을 미치게 된다.
</script>

</body>
</html>
